<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stacks</title>
  <style>
    body {
      background-color: black;
    }
    * {
      color: white;
    }
    table {
      margin: 10vh 10vw;
      border-collapse: collapse;
    }
    table,
    th,
    td {
      border-top: 2px solid white;
    }
    th,
    td {
      padding: 5px 10px;
      text-align: left;
    }
  </style>
</head>
<body>
<div class="stackyboi"></div>

<script type="text/javascript">
  let currPos = {
    row: 0,
    col: 3,
    len: 7
  };

  let prevPos = {
    row: -1,
    col: 3,
    len: 7
  };

  let gameState = {
    direction: "right",
    speed: "100",
    running: true
  };

  let stack = new Array(13).fill("O").map(i => Array(13).fill("O"));

  // js prints array lazily on the terminal for some reason. SO you gotto print it like this
  // console.log(JSON.parse(JSON.stringify(stack)))

  for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
    stack[currPos.row][i] = 1;
  }

  let stackyboi = document.querySelector(".stackyboi");

  let createTable = tableData => {
    let table = document.createElement("table");
    let tableBody = document.createElement("tbody");
    let hr = document.createElement("hr");
    let cp = document.createElement("div");
    let pp = document.createElement("div");

    tableData.forEach(rowData => {
      let row = document.createElement("tr");

      rowData.forEach(cellData => {
        let cell = document.createElement("td");
        if (cellData === "O") {
          cell.appendChild(document.createTextNode(cellData));
        } else if (cellData === 1) {
          cell.style.background = "white";
        }
        row.appendChild(cell);
      });

      tableBody.appendChild(row);
    });

    table.appendChild(tableBody);
    pp.innerHTML = "prev: " + JSON.stringify(prevPos);
    cp.innerHTML = "curr: " + JSON.stringify(currPos);

    stackyboi.innerHTML = "";
    stackyboi.appendChild(pp);
    stackyboi.appendChild(cp);
    stackyboi.appendChild(table);
    stackyboi.appendChild(hr);
  };


  createTable(stack);

  let oscillator = null;

  let foo = () => {
    oscillator = setInterval(() => {
      if (gameState.running) {
        if (gameState.direction === "right") {
          if (currPos.col + currPos.len < stack[0].length) {
            console.log("-->>", currPos);

            stack[currPos.row][currPos.col] = "O";
            stack[currPos.row][currPos.col + currPos.len] = 1;

            currPos.col++;
          } else {
            gameState.direction = "left";
          }
        } else if (gameState.direction === "left") {
          if (currPos.col > 0) {
            console.log("<<--", currPos);

            stack[currPos.row][currPos.col - 1] = 1;
            stack[currPos.row][currPos.col + currPos.len - 1] = "O";

            currPos.col--;
          } else {
            gameState.direction = "right";
          }
        }

        createTable(stack);
      }
    }, gameState.speed);
  };

  // checks stuff
  let bar = () => {
    if (prevPos.row == -1) {
      // init
      console.log("init");
      nextStep();
    } else {
      if (currPos.col === prevPos.col) {
        // perfect
        console.log("perfect");
        nextStep();
      } else {
        // wrong
        if (currPos.len === 1) {
          // end
          console.log("end");
          gameOver();
          return false;
        } else {
          // imperfect
          // TODO: conditions

          //console.log("imperfect");
          //currPos.len = currPos.len - 1;
          //nextStep();

          for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
            stack[currPos.row][i] = 'O';
          }

          if (currPos.col < prevPos.col) {
            // check overlap
            currPos.len = currPos.len - (prevPos.col-currPos.col);
            currPos.len = currPos.len >= 0 ? currPos.len : 0;
            currPos.col = prevPos.col;
          } else if (currPos.col > prevPos.col) {
            currPos.len = currPos.len - ((currPos.col+currPos.len)-(prevPos.col+prevPos.len));
            currPos.len = currPos.len >= 0 ? currPos.len : 0;
          }

          if (currPos.len === 0) {
            gameOver();
          }

          for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
            stack[currPos.row][i] = 1;
          }

          nextStep();

        }
      }
    }
  };

  let nextStep = () => {
    prevPos = { ...currPos };

    currPos.row = currPos.row + 1;
    gameState.speed = gameState.speed - 5;

    for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
      stack[currPos.row][i] = 1;
    }

    if (oscillator) {
      clearInterval(oscillator);
    }

    foo();
  };

  let gameOver = () => {
    gameState.running = false;

    alert("L O S E R");
    return 0;
  };

  document.addEventListener("click", () => {
    bar();
  });
</script>
</body>
</html>
