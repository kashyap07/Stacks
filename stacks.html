<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no">
  <title>Stacks</title>
  <style>
    body {
      background-color: black;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      padding-top: 20px;
    }
    .stackyboi {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    html {
      touch-action: manipulation;
    }
    * {
      color: white;
      user-select: none;
      -webkit-user-select: none;
      font-family: monospace;
    }
    table {
      margin-top: 30px;
      border-collapse: collapse;
      border: 1px solid white;
    }
    table,
    th,
    td {
      border-top: 1px solid white;
      border-bottom: 1px solid white;
    }
    th,
    td {
      padding: 5px 10px;
      text-align: left;

      width: 10px;
      height: 10px;
    }
  </style>
</head>
<body>
<h1 class="condition">STACKS</h1>
<div class="stackyboi"></div>

<script type="text/javascript">
  let currPos = {
    row: -1,
    col: 0,
    len: 7
  };

  let prevPos = {...currPos};

  let gameState = {
    direction: "right",
    speed: "60",
    running: false
  };

  // js prints array lazily on the terminal for some reason. SO you gotto print it like this
  // console.log(JSON.parse(JSON.stringify(stack)))

  let createStack = (rows, cols) => {
    return new Array(rows).fill("0").map(i => Array(cols).fill("0"));
  }

  let stack = createStack(10, 15);

  let stackyboi = document.querySelector(".stackyboi");

  let createTable = tableData => {
    let table = document.createElement("table");
    let tableBody = document.createElement("tbody");
    let cp = document.createElement("div");
    let pp = document.createElement("div");

    tableData.slice().reverse().forEach(rowData => {
      let row = document.createElement("tr");

      rowData.forEach(cellData => {
        let cell = document.createElement("td");
        if (cellData === "0") {
          cell.appendChild(document.createTextNode(cellData));
        } else if (cellData === 1) {
          cell.style.background = "white";
        }
        row.appendChild(cell);
      });

      tableBody.appendChild(row);
    });

    table.appendChild(tableBody);
    pp.innerHTML = "prev: " + JSON.stringify(prevPos);
    cp.innerHTML = "curr: " + JSON.stringify(currPos);

    stackyboi.innerHTML = "";
    stackyboi.appendChild(pp);
    stackyboi.appendChild(cp);
    stackyboi.appendChild(table);
  };


  createTable(stack);

  let oscillator = null;

  let foo = () => {
    oscillator = setInterval(() => {
      if (gameState.running) {
        if (gameState.direction === "right") {
          if (currPos.col + currPos.len < stack[0].length) {
            console.log("-->>", currPos);

            stack[currPos.row][currPos.col] = "0";
            stack[currPos.row][currPos.col + currPos.len] = 1;

            currPos.col++;
          } else {
            gameState.direction = "left";
          }
        } else if (gameState.direction === "left") {
          if (currPos.col > 0) {
            console.log("<<--", currPos);

            stack[currPos.row][currPos.col - 1] = 1;
            stack[currPos.row][currPos.col + currPos.len - 1] = "0";

            currPos.col--;
          } else {
            gameState.direction = "right";
          }
        }

        createTable(stack);
      }
    }, gameState.speed);
  };

  // checks stuff
  let bar = () => {
    if (!gameState.running) {
      // reset
      stack = createStack(10, 15);

      gameState = {
        direction: "right",
        speed: "60",
        running: true
      };

      currPos = {
        row: -1,
        col: 0,
        len: 7
      };

      prevPos = {...currPos};

      document.querySelector('.condition').innerHTML = 'STACKS';
    };

    if (prevPos.row == -1) {
      // init
      console.log("init");
      nextStep();
    } else {
      if (currPos.col === prevPos.col) {
        // perfect
        console.log("perfect");
        nextStep();
      } else {
        // wrong
        if (currPos.len === 1) {
          // end
          console.log("end");
          gameOver();

          return false;
        } else {
          // imperfect

          for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
            stack[currPos.row][i] = '0';
          }

          if (currPos.col < prevPos.col) {
            // check overlap
            currPos.len = currPos.len - (prevPos.col-currPos.col);
            currPos.len = currPos.len >= 0 ? currPos.len : 0;
            currPos.col = prevPos.col;
          } else if (currPos.col > prevPos.col) {
            currPos.len = currPos.len - ((currPos.col+currPos.len)-(prevPos.col+prevPos.len));
            currPos.len = currPos.len >= 0 ? currPos.len : 0;
          }

          if (currPos.len === 0) {
            gameOver();
            return false;
          }

          for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
            stack[currPos.row][i] = 1;
          }

          nextStep();
        }
      }
    }
  };

  let nextStep = () => {
    if (currPos.row === (stack.length-1)) {
      winCondition();
    } else {
      prevPos = { ...currPos };

      currPos.row = currPos.row + 1;
      gameState.speed = gameState.speed - 4;

      for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
        stack[currPos.row][i] = 1;
      }

      if (oscillator) {
        clearInterval(oscillator);
      }

      foo();
    }
    
    return 0;
  };

  let gameOver = () => {
    gameState.running = false;
    document.querySelector('.condition').innerHTML = 'GAME OVER!';
  };

  let winCondition = () => {
    for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
      stack[currPos.row][i] = '0';
    }

    if (currPos.col < prevPos.col) {
      // check overlap
      currPos.len = currPos.len - (prevPos.col-currPos.col);
      currPos.len = currPos.len >= 0 ? currPos.len : 0;
      currPos.col = prevPos.col;
    } else if (currPos.col > prevPos.col) {
      currPos.len = currPos.len - ((currPos.col+currPos.len)-(prevPos.col+prevPos.len));
      currPos.len = currPos.len >= 0 ? currPos.len : 0;
    }

    for (let i = currPos.col; i < currPos.col + currPos.len; ++i) {
      stack[currPos.row][i] = 1;
    }

    createTable(stack);
    gameState.running = false;
    document.querySelector('.condition').innerHTML = 'YOU WIN!';
  }

  document.addEventListener("click", () => {
    bar();
  });

  document.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'Enter') {
      e.preventDefault();
      bar();
    }
  });

  /*document.addEventListener("touchstart", () => {
    bar();
  });*/

</script>
</body>
</html>
